# react-practice

모든 컴포넌트들을 div로 감싸면서 생기는 이슈
-----
1. 최종적으로 렌더링 된 상태에서 불필요한 div요소들이 너무 많다. -> 속도 저하
2. 수많은 div요소들은 스타일링을 망친다.


React Portal
----
포탈 기능은 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 것을 말한다.

포탈 사용 이유
----
기술적으로 포탈을 사용하지 않아도 동작은 잘 작동한다. 하지만 의미론적인 측면에서 보면 특정 컴포넌트가 조건에 따라 오버레이를 사용하는 경우(모달, 다이얼로그) 간결한 HTML구조를 가지는 것도 힘들다. 또한 부모 컴포넌트의 스타일 상속에 영향을 받기 때문에 스타일링으로 이러한 상속또한 신경써줘야 한다.     
이 때문에 포탈을 사용한다. tree구조(부모-자식)에서 특정 부분을 독립적으로 간주하여 다른 곳에서 렌더링함으로써 스타일링의 제약에서 벗어날 수 있고, 간결한 HTML 구조를 가짐으로써 좀 더 시멘틱한 코드를 작성할 수 있게 된다. 그렇기 때문에 오버레이를 이용하는 컴포넌트는 포탈을 이용한다.


Ref
----
리액트에서 ref는 useRef훅을 이용해서 Dom에 직접 접근할 수 있다. Dom에 직접 접근하는 게 일반적으로는 좋지 않지만 특정 상황에서는 코드를 더 줄이고 효율적으로 작동하게 할 수 있다.   
예시로 사용자의 인풋값을 useState를 다루는 경우를 보았을때 한글자마다 state가 변하는 것은 과도한 변화로 볼 수 있다. 이를 Ref를 통해서 전체를 받아와서 다룰 수 있다.   
이로인해 속도 뿐만 아니라 코드가 간결해지는 것을 볼 수 있다. 단점은 Dom조작을 한다는 것 하나이다. 되도록 ref는 사용하지 않는 것을 권장하지만 때로는 ref를 사용함으로써 효율을 올리는 것이 좋아 보인다.

제어 컴포넌트 vs 비제어 컴포넌트
-----
인풋 요소에 대해서 state를 관리하면서 value값으로 피드백을 주는 형태를 제어 컴포넌트, 리액트의 훅인 useRef를 이용하지만 결국 Dom 엑세스에 직접 접근해서 Dom API를 이용하여 제어하는 것이 비제어 컴포넌트이다.    
비제어 컴포넌트는 상태에 따라 인풋에 피드백을 하는 것이 아닌 직접 DOM조작을 하는 것이기 때문에 비제어 컴포넌트라고 불린다.

Side-Effect
-----
리액트에서 side-effect는 컴포넌트 내에서 input과 output외에 다른 값을 조작할 때 side-effect라고 부른다.     
대표적인 예로는 Http요청, timer설정, 외부변수의 조작과 같은 것들이 있다.    즉 A라는 함수에 B라는 매개변수를 넣어 조작할 때 A함수 내에서 갑자기 C에 대한 로직을 사용할 때 이를 사이드 이펙트로 처리한다. 왜냐하면 해당 로직에서 연관성이 없고 비동기적인 부분이 있을 수 있기 때문이다.     
사이드 이펙트라함은 보통 비동기데이터에 대한 부분에서 많이 쓰이는데 사실상 앞서 말한 것처럼 한가지 기능내에서 외부의 값을 조작하려할 때 따로 side-effect로 빼서 사용할 수 있다.   
email과 password에 대해 입력하는 로직과 form제출에 대한 validation이 같은 로직에 있을 때 이는 분리 시켜주는 것이 좋다고 판단하고 side-effect로 따로 빼는 것을 예로 들 수 있다.   


clean-up
-----
useEffect 내부에서 return () => {}과 같은 형태를 사용한다면 이는 클린업 함수이다. 클린업 함수의 개념을 확실히 이해하지는 못했지만 컴포넌트가 unmount될 때 실행되며 useEffect에 정의해 놓은 이전 side-effect를 처리한다는 것임을 알았다. 즉 useEffect의 dependency로 설정된 값들이 변화할때마다 cleanup함수가 먼저 실행이 되는데 이 공간에서 바로 전의 side-effect에 대한 내용을 업데이트하는 것이다. 그리고 이후 다음 side-effect가 실행이 되는 것이다.    
이를 사용하는 예시로는 clearTimeOut이 있는데 사용자가 인풋내용에 대해 입력할때마다 useEffect안의 함수가 실행되는 것은 비효율적이다. 때문에 이런 함수는 비동기로 500ms정도의 타이머를 설정해놓고 clean up내부에서 clearTimeOut으로 이전에 해당하는 내용을 지움으로써 특정 시간이 지났을 때만 useEffect를 실행하게 할 수 있게 된다.    
즉 email에 csh7215@naver.com라는 것을 입력했을 때 각 키 스트로크마다 500ms가 걸리지만 이들은 cleanup때문에 전부 지워지고 마지막 m을 클릭하고 특정 시간이 지났을 떄(500ms) 

context API
-----
context API는 왜 사용하는가를 고민해보았을 때 props로 인한 불필요한 데이터 이동을 막기 위해서라고 볼 수 있다.   
context API를 사용하기 전에 고려해야할 점은 props로 전달하기 불편할 만큼 깊이가 깊은가?와 상위컴포넌트에서 직접 컴포넌트를 부르면 안되는 것인가? 이 두 가지를 고려해본 뒤 둘 다 아닐때 적용하는 게 좋다.    
사용방법은 2가지로 나뉜다.   

consumer vs react hook
-----
consumer 방법은 데이터를 제공하고자 하는 컴포넌트에서 Provider를 정의하고 데이터를 사용하고자 하는 부분에서 Consumer를 정의하여 사용하면 된다. 주의할 점은 사용하고자하는 컴포넌트 내부에서 Consumer를 정의한 뒤``` {(context) => return {//html code}}```와 같이 {}를 사용해서 출력하고자하는 html코드들을 return해야한다는 점이다. 이 부분이 다소 번거롭고 코드가 깔끔해보이지 않을 수 있다. 
      
react hook방법은 useContext훅을 불러와서 사용하는 것이다. useContent의 매개변수로 불러온 Context를 넣어주면 가져오고자 하는 context에 쉽게 접근할 수 있다. 때문에 이 방법을 더 선호하는 것으로 알고있다.   





