# react-practice

모든 컴포넌트들을 div로 감싸면서 생기는 이슈
-----
1. 최종적으로 렌더링 된 상태에서 불필요한 div요소들이 너무 많다. -> 속도 저하
2. 수많은 div요소들은 스타일링을 망친다.


React Portal
----
포탈 기능은 부모 컴포넌트의 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링하는 것을 말한다.

포탈 사용 이유
----
기술적으로 포탈을 사용하지 않아도 동작은 잘 작동한다. 하지만 의미론적인 측면에서 보면 특정 컴포넌트가 조건에 따라 오버레이를 사용하는 경우(모달, 다이얼로그) 간결한 HTML구조를 가지는 것도 힘들다. 또한 부모 컴포넌트의 스타일 상속에 영향을 받기 때문에 스타일링으로 이러한 상속또한 신경써줘야 한다.     
이 때문에 포탈을 사용한다. tree구조(부모-자식)에서 특정 부분을 독립적으로 간주하여 다른 곳에서 렌더링함으로써 스타일링의 제약에서 벗어날 수 있고, 간결한 HTML 구조를 가짐으로써 좀 더 시멘틱한 코드를 작성할 수 있게 된다. 그렇기 때문에 오버레이를 이용하는 컴포넌트는 포탈을 이용한다.


Ref
----
리액트에서 ref는 useRef훅을 이용해서 Dom에 직접 접근할 수 있다. Dom에 직접 접근하는 게 일반적으로는 좋지 않지만 특정 상황에서는 코드를 더 줄이고 효율적으로 작동하게 할 수 있다.   
예시로 사용자의 인풋값을 useState를 다루는 경우를 보았을때 한글자마다 state가 변하는 것은 과도한 변화로 볼 수 있다. 이를 Ref를 통해서 전체를 받아와서 다룰 수 있다.   
이로인해 속도 뿐만 아니라 코드가 간결해지는 것을 볼 수 있다. 단점은 Dom조작을 한다는 것 하나이다. 되도록 ref는 사용하지 않는 것을 권장하지만 때로는 ref를 사용함으로써 효율을 올리는 것이 좋아 보인다.

제어 컴포넌트 vs 비제어 컴포넌트
-----
인풋 요소에 대해서 state를 관리하면서 value값으로 피드백을 주는 형태를 제어 컴포넌트, 리액트의 훅인 useRef를 이용하지만 결국 Dom 엑세스에 직접 접근해서 Dom API를 이용하여 제어하는 것이 비제어 컴포넌트이다.    
비제어 컴포넌트는 상태에 따라 인풋에 피드백을 하는 것이 아닌 직접 DOM조작을 하는 것이기 때문에 비제어 컴포넌트라고 불린다.

Side-Effect
-----
리액트에서 side-effect는 컴포넌트 내에서 input과 output외에 다른 값을 조작할 때 side-effect라고 부른다.     
대표적인 예로는 Http요청, timer설정, 외부변수의 조작과 같은 것들이 있다.    즉 A라는 함수에 B라는 매개변수를 넣어 조작할 때 A함수 내에서 갑자기 C에 대한 로직을 사용할 때 이를 사이드 이펙트로 처리한다. 왜냐하면 해당 로직에서 연관성이 없고 비동기적인 부분이 있을 수 있기 때문이다.     
사이드 이펙트라함은 보통 비동기데이터에 대한 부분에서 많이 쓰이는데 사실상 앞서 말한 것처럼 한가지 기능내에서 외부의 값을 조작하려할 때 따로 side-effect로 빼서 사용할 수 있다.   
email과 password에 대해 입력하는 로직과 form제출에 대한 validation이 같은 로직에 있을 때 이는 분리 시켜주는 것이 좋다고 판단하고 side-effect로 따로 빼는 것을 예로 들 수 있다.   


clean-up
-----
useEffect 내부에서 return () => {}과 같은 형태를 사용한다면 이는 클린업 함수이다. 클린업 함수의 개념을 확실히 이해하지는 못했지만 컴포넌트가 unmount될 때 실행되며 useEffect에 정의해 놓은 이전 side-effect를 처리한다는 것임을 알았다. 즉 useEffect의 dependency로 설정된 값들이 변화할때마다 cleanup함수가 먼저 실행이 되는데 이 공간에서 바로 전의 side-effect에 대한 내용을 업데이트하는 것이다. 그리고 이후 다음 side-effect가 실행이 되는 것이다.    
이를 사용하는 예시로는 clearTimeOut이 있는데 사용자가 인풋내용에 대해 입력할때마다 useEffect안의 함수가 실행되는 것은 비효율적이다. 때문에 이런 함수는 비동기로 500ms정도의 타이머를 설정해놓고 clean up내부에서 clearTimeOut으로 이전에 해당하는 내용을 지움으로써 특정 시간이 지났을 때만 useEffect를 실행하게 할 수 있게 된다.    
즉 email에 csh7215@naver.com라는 것을 입력했을 때 각 키 스트로크마다 500ms가 걸리지만 이들은 cleanup때문에 전부 지워지고 마지막 m을 클릭하고 특정 시간이 지났을 떄(500ms) 

context API
-----
context API는 왜 사용하는가를 고민해보았을 때 props로 인한 불필요한 데이터 이동을 막기 위해서라고 볼 수 있다.   
context API를 사용하기 전에 고려해야할 점은 props로 전달하기 불편할 만큼 깊이가 깊은가? 상위컴포넌트에서 직접 컴포넌트를 부르면 안되는 것인가? props로 인한 데이터 재사용이 자주 쓰이지는 않는가? 이 두 가지를 고려해본 뒤 둘 다 아닐때 적용하는 게 좋다.    
사용방법은 2가지로 나뉜다.   

consumer vs react hook
-----
consumer 방법은 데이터를 제공하고자 하는 컴포넌트에서 Provider를 정의하고 데이터를 사용하고자 하는 부분에서 Consumer를 정의하여 사용하면 된다. 주의할 점은 사용하고자하는 컴포넌트 내부에서 Consumer를 정의한 뒤``` {(context) => return {//html code}}```와 같이 {}를 사용해서 출력하고자하는 html코드들을 return해야한다는 점이다. 이 부분이 다소 번거롭고 코드가 깔끔해보이지 않을 수 있다. 
      
react hook방법은 useContext훅을 불러와서 사용하는 것이다. useContent의 매개변수로 불러온 Context를 넣어주면 가져오고자 하는 context에 쉽게 접근할 수 있다. 때문에 이 방법을 더 선호하는 것으로 알고있다.   

AuthContextProvider
-----
로그인 인증과 관련한 부분을 auth-context.js파일에 담아서 관리할 수 있다.   
즉 context에 대한 객체 뿐만 아니라 useState를 통해서 반응형으로 다룰 수 있고, useEffect도 사용가능하며, 이곳에서 함수를 정의한 뒤 prop으로 넘겨주어 Provider에 wrapping되고 있는 모든 컴포넌트 들에 대하여 이 인증로직 모듈을 사용할 수 있게 된다. 이는 컴포넌트 분할측면에서 크게 의미가 있으며 login과 같이 전역적으로 사용하는 로직들은 이렇게 분리하여 다루는 것이 효과적일 수 있다.

버튼 입장에서의 context
-----
props는 버튼 설정에, context는 컴포넌트나 전체 앱 state의 관리에 쓰는 게 좋다.    
왜냐하면 버튼 설정에 context를 주게 되면(예를 들어 유저 context를) 유저 context에 한정하여 버튼을 제공하기 때문이다.   
외로 context는 자주 바뀌는 state에 대해서는 적절하지 않다.   

리액트 훅 3가지 룰
-----
리액트 훅에 대해서 세가지 룰이 있다.
1. 무조건 리액트 컴포넌트나 맞춤 훅안에서만 정의할 수 있다.
2. 무조건 Top-level에서 훅을 호출해야한다. -> 리액트 컴포넌트 내부에 useEffect를 사용하면 top-level이지만 이 useEffect 안에 또 훅을 사용하면 이는 top-level이 아니므로 위반된다. 또한 block내부에서 사용할 수 없다.(if문 내부에서 사용 불가)
3. 세 번째는 useEffect에만 해당하는 룰인데 useEffect 함수 내부에서 참조하고 있는 값들(브라우저 api와 같은 것을 제외한 리액트 컴포넌트에서 사용중인 값)을 dependency에 정의하는 것이다.


useImperativeHandle,  React.forwardRef
-----
이 두개의 키워드는 컴포넌트에 ref를 전달할 떄 사용하는 키워드이다.   
useImperativeHandle은 매개변수로 두 개가 올 수 있는데 첫번째 매개변수는 부모로부터 온 ref, 두번째 매개변수는 객체를 리턴하는 함수가 온다.     
필자가 이해하기로는 자식 컴포넌트에서 정의한 메소드들을 props나 state의 일반적인 데이터흐름으로 전달해주는 것이 아닌 명령적으로 부모로 노출시키는 훅으로 이해했다.    
React.forwardRef는 자식 컴포넌트에서 ref를 받기위해서 특별한 형태의 컴포넌트를 리턴해야하기 때문에 사용한다. 본래는 props하나만 받았는데 이러한 형태의 함수에서는 두번째 인자로 ref도 받게 된다.   
ref의 사용은 되도록이면 지양하는 게 맞지만 focus나 scroll같은 이벤트를 줄 때는 ref를 통해 적절히 사용하는 것이 좋아보인다.




